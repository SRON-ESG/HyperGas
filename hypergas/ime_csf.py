#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2023 HyperGas developers
#
# This file is part of hypergas.
#
# hypergas is a library to retrieve trace gases from hyperspectral satellite data
"""IME/CSF method of calculating gas emission rates"""

import gc
import logging

import geopandas as gpd
import numpy as np
import pyresample
import xarray as xr
from pyproj import Transformer
from pyresample.geometry import SwathDefinition
from scipy.stats.mstats import trimmed_std
from shapely.geometry import LineString, Point
from shapely.strtree import STRtree

from hypergas.ddeq_plumeline import Poly2D, compute_plume_coordinates
from hypergas.landmask import Land_mask

# set the logger level
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s: %(message)s',
                    datefmt='%Y/%m/%d %H:%M:%S')
LOG = logging.getLogger(__name__)


# constants
mass = {'ch4': 16.04e-3, 'co2': 44.01e-3, 'co': 28.01e-3}  # molar mass [kg/mol]
mass_dry_air = 28.964e-3  # molas mass dry air [kg/mol]
grav = 9.8  # gravity (m s-2)
molar_volume = 22.4  # L/mol at STP


'''
instrument data
    pixel_res: meters
    alpha: IME alphas
'''
emit_info = {
    'platform': 'EMIT', 'instrument': 'emi', 'provider': 'NASA-JPL', 'pixel_res': 60,
    'alpha_area': {'alpha1': 0., 'alpha2': 0.67, 'alpha3': 0.45, 'resid': 0.053},
    'alpha_point': {'alpha1': 0., 'alpha2': 0.28, 'alpha3': 0.49, 'resid': 0.033},
    'beta_area': {'beta1': 1.13, 'beta2': 0, 'resid': -0.017},
    'beta_point': {'beta1': 1.13, 'beta2': 0, 'resid': -0.042},
}

enmap_info = {
    'platform': 'EnMAP', 'instrument': 'hsi', 'provider': 'DLR', 'pixel_res': 30,
    'alpha_area': {'alpha1': 0., 'alpha2': 0.69, 'alpha3': 0.37, 'resid': 0.034},
    'alpha_point': {'alpha1': 0., 'alpha2': 0.43, 'alpha3': 0.38, 'resid': 0.014},
    'beta_area': {'beta1': 1.22, 'beta2': 0, 'resid': -0.004},
    'beta_point': {'beta1': 1.14, 'beta2': 0, 'resid': -0.025},
}
prisma_info = {
    'platform': 'PRISMA', 'instrument': 'hsi', 'provider': 'ASI', 'pixel_res': 30,
    'alpha_area': {'alpha1': 0., 'alpha2': 0.70, 'alpha3': 0.37, 'resid': 0.035},
    'alpha_point': {'alpha1': 0., 'alpha2': 0.42, 'alpha3': 0.39, 'resid': 0.014},
    'beta_area': {'beta1': 1.22, 'beta2': 0, 'resid': -0.007},
    'beta_point': {'beta1': 1.14, 'beta2': 0, 'resid': -0.022},
}
sensor_info = {'EMIT': emit_info, 'EnMAP': enmap_info, 'PRISMA': prisma_info}


class IME_CSF():
    def __init__(self, sensor,
                 longitude_source, latitude_source,
                 plume_nc_filename, plume_name, ipcc_sector,
                 gas='ch4', wind_source='ERA5', wspd_manual=None,
                 land_only=True, land_mask_source='OSM'):
        """Initialize IME_CSF.

        Args:
            sensor (str):
                satellite sensor name
            longitude_source (float):
                longitude of plume source
            latitude_source (float):
                latitude of plume source
            plume_nc_filename (str):
                plume NetCDF file generated by `emiss.export_plume_nc`
            plume_name (str):
                the plume name (e.g. 'plume0')
            ipcc_sector (str):
                the sector name
                    'Electricity Generation (1A1)', 'Coal Mining (1B1a)',
                    'Oil & Gas (1B2)', 'Livestock (4B)', 'Solid Waste (6A)', 'Other'
            gas (str):
                the trace gas name
            wind_source (str):
                wind source name
            wspd_manual (float):
                Default: None (using the wspd from wind_source data)
            land_only (boolean):
                whether only considering land pixels
            land_mask_source:
                data source for creating land mask
        """
        self.gas = gas
        self.longitude_source = longitude_source
        self.latitude_source = latitude_source
        self.plume_nc_filename = plume_nc_filename
        self.plume_name = plume_name
        self.wind_source = wind_source
        self.wspd_manual = wspd_manual
        self.land_only = land_only
        self.land_mask_source = land_mask_source

        self.info = sensor_info[sensor]
        self.pixel_res = self.info['pixel_res']

        self.ds = xr.open_dataset(self.plume_nc_filename, decode_coords='all')
        self.unit = self.ds[self.gas].attrs['units']

        # get the crs
        if self.ds.rio.crs:
            self.crs = self.ds.rio.crs
        else:
            self.crs = None

        # get the masked plume data
        self.gas_mask = self.ds.dropna(dim='y', how='all').dropna(dim='x', how='all')[self.gas]

        if ipcc_sector == 'Solid Waste (6A)':
            # area source
            self.alpha = self.info['alpha_area']
            self.beta = self.info['beta_area']
            self.alpha_replace = self.info['alpha_point']
            self.beta_replace = self.info['beta_point']
            # set residual as zero as we will use the point-source calibration
            self.alpha_replace['resid'] = 0
            self.beta_replace['resid'] = 0
        else:
            # point source
            self.alpha = self.info['alpha_point']
            self.beta = self.info['beta_point']
            # use residual as uncertainty
            self.alpha_replace = self.info['alpha_point']
            self.beta_replace = self.info['beta_point']

    def calc_emiss(self):
        """Calculate emission rate (kg/h)"""
        wind_speed, wdir, wind_speed_all, wdir_all, wind_source_all, l_eff, u_eff, IME, Q, Q_err, \
            err_random, err_wind, err_calib = self.ime()
        Q_fetch, Q_fetch_err, err_ime_fetch, err_wind_fetch = self.ime_fetch()
        ds_csf, l_csf, u_eff_csf, Q_csf, Q_csf_err, err_random_csf, err_wind_csf, err_calib_csf = self.csf()

        return wind_speed, wdir, wind_speed_all, wdir_all, wind_source_all, l_eff, u_eff, IME, Q, Q_err, \
            err_random, err_wind, err_calib, Q_fetch, Q_fetch_err, err_ime_fetch, err_wind_fetch, \
            ds_csf, l_csf, u_eff_csf, Q_csf, Q_csf_err, err_random_csf, err_wind_csf, err_calib_csf

    def _create_circular_mask(self, h, w, center=None, radius=None):
        """Create circle mask by radius and center"""
        if center is None:
            # use the middle of the image
            center = (int(w/2), int(h/2))
        if radius is None:
            # use the smallest distance between the center and image walls
            radius = min(center[0], center[1], w-center[0], h-center[1])

        Y, X = np.ogrid[:h, :w]
        dist_from_center = np.sqrt((X - center[0])**2 + (Y-center[1])**2)

        mask = dist_from_center <= radius

        return mask

    def _ime_sum(self, gas_mask):
        """Calculate the total gas mass (kg) in plume mask"""
        if self.unit == 'ppb':
            delta_omega = gas_mask.sum().values * 1.0e-9 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif self.unit == 'ppm':
            delta_omega = gas_mask.sum().values * 1.0e-6 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif self.unit == 'ppm m':
            delta_omega = gas_mask.sum().values * (1/1e6) * (1000) * (1/molar_volume) * mass[self.gas]
        else:
            raise ValueError(f"Unit '{self.unit}' is not supported yet. Please add it here.")

        return delta_omega * self.area

    def _csf_sum(self, gas_mask):
        """Cailculate the total gas mass (kg) along one CSF line"""
        if self.unit == 'ppb':
            delta_omega = gas_mask.sum().values * 1.0e-9 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif self.unit == 'ppm':
            delta_omega = gas_mask.sum().values * 1.0e-6 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif self.unit == 'ppm m':
            delta_omega = gas_mask.sum().values * (1/1e6) * (1000) * (1/molar_volume) * mass[self.gas]
        else:
            raise ValueError(f"Unit '{self.unit}' is not supported yet. Please add it here.")

        return delta_omega * self.pixel_res

    def _get_index_nearest(self, lons, lats, lon_target, lat_target):
        # define the areas for data and source point
        area_source = SwathDefinition(lons=lons, lats=lats)
        area_target = SwathDefinition(lons=np.array([lon_target]), lats=np.array([lat_target]))

        # Determine nearest (w.r.t. great circle distance) neighbour in the grid.
        _, _, index_array, distance_array = pyresample.kd_tree.get_neighbour_info(
            source_geo_def=area_source, target_geo_def=area_target, radius_of_influence=50,
            neighbours=1)

        # get_neighbour_info() returns indices in the flattened lat/lon grid. Compute the 2D grid indices:
        y_target, x_target = np.unravel_index(index_array, area_source.shape)

        return y_target, x_target

    def _calc_wind_error(self, IME, l_eff):
        """Calculate wind error with random distribution"""
        # Generate U10 distribution
        #   uncertainty = 50%, if wspd <= 3 m/s
        #   uncertainty = 1.5 m/s, if wspd > 3 m/s
        if self.wspd <= 3:
            sigma = self.wspd * 0.5
        else:
            sigma = 1.5

        wspd_distribution = np.random.normal(self.wspd, sigma, size=1000)

        # Calculate Ueff distribution
        u_eff_distribution = self.alpha['alpha1'] * np.log(wspd_distribution) + \
            self.alpha['alpha2'] + self.alpha['alpha3'] * wspd_distribution

        # Calculate Q distribution
        Q_distribution = u_eff_distribution * IME / l_eff

        # Calculate standard deviation of Q distribution
        wind_error = np.nanstd(Q_distribution)

        return wind_error

    def _calc_wind_error_fetch(self, ime_l_mean):
        """Calculate wind error with random distribution for IME-fetch"""
        if self.wspd <= 3:
            sigma = self.wspd * 0.5
        else:
            sigma = 1.5

        wspd_distribution = np.random.normal(self.wspd, sigma, size=1000)

        # Calculate Q distribution
        Q_distribution = ime_l_mean * wspd_distribution

        # Calculate standard deviation of Q distribution
        wind_error = np.std(Q_distribution)

        return wind_error

    def _calc_wind_error_csf(self, C):
        """Calculate wind error with random distribution"""
        # Generate U10 distribution
        #   uncertainty = 50%, if wspd <= 3 m/s
        #   uncertainty = 1.5 m/s, if wspd > 3 m/s
        if self.wspd <= 3:
            sigma = self.wspd * 0.5
        else:
            sigma = 1.5

        wspd_distribution = np.random.normal(self.wspd, sigma, size=1000)

        # Calculate Ueff distribution
        u_eff_distribution = self.beta['beta1'] * wspd_distribution + self.beta['beta2']

        # Calculate Q distribution
        Q_distribution = u_eff_distribution * C

        # Calculate standard deviation of Q distribution
        wind_error = np.nanstd(Q_distribution)

        return wind_error

    def _calc_random_err(self, da_gas, gas_mask):
        """Calculate random error by moving plume around the whole scene"""
        # crop gas field to valid region
        gas_mask_crop = gas_mask.where(~gas_mask.isnull()).dropna(dim='y', how='all').dropna(dim='x', how='all')

        # get the shape of input data and mask
        bkgd_rows, bkgd_cols = gas_mask.shape
        mask_rows, mask_cols = gas_mask_crop.shape

        # Insert plume mask data at a random position
        IME_noplume = []
        self.ch4_bkgds = []

        LOG.info('Moving plume around the scene for valid background masks')
        while len(IME_noplume) <= 100:
            # Generate random row and column index to place b inside a
            y_move_pixel = bkgd_rows - mask_rows
            x_move_pixel = bkgd_cols - mask_cols
            y_shift = np.random.randint(-y_move_pixel, y_move_pixel)
            x_shift = np.random.randint(-x_move_pixel, x_move_pixel)

            ch4_shift = gas_mask.shift(y=y_shift, x=x_shift)
            ch4_shift_notnull = ch4_shift.notnull().values

            # check if 1) the plume shape is not outside of scene 2) plume pixels are not included
            n_valid_pixel = gas_mask.notnull().sum()
            no_outside = ch4_shift.notnull().sum() == n_valid_pixel
            no_plume = gas_mask.where(ch4_shift_notnull).isnull().all()

            if no_outside and no_plume:
                ch4_bkgd = da_gas.where(ch4_shift_notnull)
                # 3) all valid value
                if da_gas.notnull().where(ch4_shift_notnull, False).sum() == n_valid_pixel:
                    self.ch4_bkgds.append(ch4_bkgd)
                    IME_noplume.append(self._ime_sum(ch4_bkgd))

        LOG.info('Moving plume around the scene for valid background masks (Done)')

        std_value = trimmed_std(np.array(IME_noplume), (1e-3, 1e-3))
        del IME_noplume, ch4_bkgd
        gc.collect()

        return std_value

    def _calc_random_err_csf(self, C, u_eff, match_lists):
        """Calculate random error by moving plume around the whole scene"""
        C_noplume = []

        for ch4_bkgd in self.ch4_bkgds:
            ch4_bkgd_valid = ch4_bkgd.stack(z=("x", "y")).dropna(dim='z')
            C_lines = []
            for match_list in match_lists:
                gas_match = ch4_bkgd_valid.isel(z=match_list)
                C = self._csf_sum(gas_match)
                C_lines.append(C)
            C_noplume.append(np.array(C_lines).mean())

        std_value = trimmed_std(np.array(C_noplume), (1e-3, 1e-3))
        del C_noplume
        gc.collect()

        return std_value

    def _calc_calibration_error(self, IME, u_eff, l_eff):
        """Calculate wind calibration error by replacing alphas"""
        # Calculate Ueff
        u_eff_replace = self.alpha_replace['alpha1'] * \
            np.log(self.wspd) + self.alpha_replace['alpha2'] + \
            self.alpha_replace['alpha3'] * self.wspd + self.alpha_replace['resid']

        # Calculate uncertainty
        error = abs(u_eff_replace - u_eff) * IME / l_eff

        return error

    def _calc_calibration_error_csf(self, C, u_eff):
        """Calculate wind calibration error by replacing betas"""
        # Calculate Ueff
        u_eff_replace = self.beta_replace['beta1'] * self.wspd + self.beta_replace['beta2'] + self.beta_replace['resid']
        if u_eff_replace == u_eff:
            # In case betas are same for area and point sources
            u_eff_replace = self.beta_replace['beta1'] * self.wspd + self.beta_replace['beta2'] + self.beta['resid']

        # Calculate uncertainty
        error = abs(u_eff_replace - u_eff) * C

        return error

    def _def_csf_lines(self, npixel_interval):
        """Define CSF lines for quantification

        Args:
            npixel_interval: interval of CSF lines (unit: n*pixel_size)

        Return:
            center_curve
            csf_lines
            ds_csf (xarray Dataset):
                yp (y, x): y coord of the plume coords
                xp (y, x): x coord of the plume coords
                center_line_y (plume_center): y coord (UTM) of the centerline
                center_line_x (plume_center): x coord (UTM) of the centerline
                csf_line (plume_center): the csf line (UTM)
        """
        def create_perpendiculars(curve, interval, line_width):
            line_length_shap = curve.length
            start, end, stepsize, sign = 0, line_length_shap, interval, 1

            transect_lines = []
            initial_slope = None
            for dist_along_line in np.arange(start, end, stepsize):
                point = curve.interpolate(dist_along_line)
                close_point = curve.interpolate(dist_along_line + sign * 0.2 * interval)
                dx = close_point.x - point.x
                if abs(dx) < 1.0e-8:  # Avoid rare cases of division by 0
                    dx = 1.0e-8
                dy = close_point.y - point.y
                slope = dy / dx  # Slope of the spline

                # dy and dx are perpendicular to the spline (hence the minus-slope)
                dy = np.sign(slope) * np.sqrt((0.5 * line_width)**2 / (1 + slope**2))
                dx = -slope * dy
                if initial_slope is None:
                    initial_slope = slope
                perp_line = LineString([[point.x - dx, point.y - dy], [point.x + dx, point.y + dy]])
                transect_lines.append(perp_line)
            return transect_lines

        ds = self.ds

        # get 1d array of plume data
        self.gas_valid = ds[self.gas].stack(z=('x', 'y')).dropna(dim='z')

        # get plume source location in UTM projection
        transformer = Transformer.from_crs("EPSG:4326", ds.rio.crs, always_xy=True)
        x_source, y_source = transformer.transform(ds.attrs['plume_longitude'],  ds.attrs['plume_latitude'])

        # create the centerline through the plume
        curve = Poly2D(
            x=self.gas_valid.x,
            y=self.gas_valid.y,
            w=xr.full_like(self.gas_valid, 1),  # all pixels are inside plume
            degree=2,
            x_o=x_source,
            y_o=y_source,
            force_source=True
        )

        # calculate x and y in the plume coordinate
        xp, yp, t_min, t_max = compute_plume_coordinates(ds[self.gas], curve, which="centers")

        # mask data
        xp = xp.where(ds[self.gas].notnull())
        yp = yp.where(ds[self.gas].notnull())

        # calculate plume length and set orientation for centerline
        positive_num = xp.where(xp > 0).count()
        negative_num = xp.where(xp < 0).count()
        interval = self.pixel_res*npixel_interval

        if positive_num >= negative_num:
            t = np.arange(curve.t_o, t_max, interval)
        else:
            t = np.arange(curve.t_o, t_min, -interval)

        t = t.astype('float')

        # get the centerline
        center_curve = np.vstack((curve(t=t)[0], curve(t=t)[1])).T.astype('float')

        # get the csf line
        length = (yp.max() - yp.min())*1.5  # make the CSF lines longer
        csf_lines = create_perpendiculars(LineString(center_curve), interval=interval, line_width=length)

        ds.close()
        del ds
        gc.collect()

        return center_curve, csf_lines

    def _emiss_csf_lines(self, csf_lines):
        """Calculate gas emission rate at each CSF line"""
        # create gdf of center points of plume pixel
        gdf = gpd.GeoDataFrame({'x': self.gas_valid.coords['x'], 'y': self.gas_valid.coords['y']})
        gdf['center'] = gdf.apply(lambda x: Point(x['x'], x['y']), axis=1)

        # create square around the pixel center
        gdf['polygon'] = gdf['center'].buffer(self.pixel_res/2, cap_style=3)

        # Query the spatial index for potential intersections
        # https://stackoverflow.com/a/43105613/7347925
        spatial_index = STRtree(gdf['polygon'])

        def check_intersections(spatial_index, polygon, line):
            potential_matches = spatial_index.query(line)

            # Check if there is any intersection with the potential matches
            match_list = potential_matches[[line.intersects(poly) for poly in polygon.iloc[potential_matches]]]

            return match_list

        # calculate emission rate using intersected pixels
        Q_lines = []
        match_lists = []
        u_eff = self.beta['beta1'] * self.wspd + self.beta['beta2']

        for line in csf_lines:
            match_list = check_intersections(spatial_index, gdf['polygon'], line)

            if len(match_list) > 0:
                gas_match = self.gas_valid.isel(z=match_list)
                C = self._csf_sum(gas_match)
                Q_lines.append(C * u_eff)
                match_lists.append(match_list)
            else:
                Q_lines.append(np.nan)

        return C, u_eff, np.array(Q_lines), match_lists

    def _csf_dataset(self, center_curve, csf_lines, Q_lines):
        """Combine CSF info into one xarray Dataset"""
        x_center = center_curve[:, 0]
        y_center = center_curve[:, 1]

        x_start = [line.xy[0][0] for line in csf_lines]
        x_end = [line.xy[0][1] for line in csf_lines]
        y_start = [line.xy[1][0] for line in csf_lines]
        y_end = [line.xy[1][1] for line in csf_lines]

        ds_csf = xr.Dataset(
            data_vars=dict(emission_rate=(['csf_line'], Q_lines*3600),
                           x_start=(['csf_line'], x_start),
                           x_end=(['csf_line'], x_end),
                           y_start=(['csf_line'], y_start),
                           y_end=(['csf_line'], y_end),
                           x_center=('ceter_line', x_center),
                           y_center=('ceter_line', y_center),
                           ),
        )

        ds_csf['emission_rate'].attrs['description'] = 'emission rate at each csf line'
        ds_csf['emission_rate'].attrs['units'] = 'kg h-1'

        ds_csf['x_start'].attrs['description'] = 'start coord (x) of csf line'
        ds_csf['x_start'].attrs['units'] = 'm'
        ds_csf['x_end'].attrs['description'] = 'end coord (x) of csf line'
        ds_csf['x_end'].attrs['units'] = 'm'

        ds_csf['y_start'].attrs['description'] = 'start coord (y) of csf line'
        ds_csf['y_start'].attrs['units'] = 'm'
        ds_csf['y_end'].attrs['description'] = 'end coord (y) of csf line'
        ds_csf['y_end'].attrs['units'] = 'm'

        ds_csf['x_center'].attrs['description'] = 'x coord of center line'
        ds_csf['x_center'].attrs['units'] = 'm'
        ds_csf['y_center'].attrs['description'] = 'y coord of center line'
        ds_csf['y_center'].attrs['units'] = 'm'

        if self.crs is not None:
            ds_csf.rio.write_crs(self.crs, inplace=True)

        return ds_csf

    def csf(self, npixel_interval=2.5):
        """Calculate the emission rate (kg/h) using CSF method
        Args:
            npixel_interval: interval of CSF lines (unit: n*pixel_res)
        """
        LOG.info('Calculating CSF')
        # set the plume centerline and CSF lines
        center_curve, csf_lines = self._def_csf_lines(npixel_interval)
        l_csf = LineString(center_curve).length

        # calculate the emission rate at each CSF line
        C, u_eff, Q_lines, match_lists = self._emiss_csf_lines(csf_lines)
        ds_csf = self._csf_dataset(center_curve, csf_lines, Q_lines)

        # calculate the mean emission rate
        Q = np.nanmean(Q_lines)

        # ---- uncertainty ----
        # 1. random
        LOG.info('Calculating random error')
        C_std = self._calc_random_err_csf(C, u_eff, match_lists)
        err_random = u_eff * C_std

        # 2. wind error
        LOG.info('Calculating wind error')
        err_wind = self._calc_wind_error_csf(C)

        # 3. calibration error
        LOG.info('Calculating calibration error')
        err_calib = self._calc_calibration_error_csf(C, u_eff)

        # sum error
        Q_err = np.sqrt(err_random**2 + err_wind**2 + err_calib**2)

        return ds_csf, l_csf, u_eff, Q*3600, Q_err*3600, \
            err_random*3600, err_wind*3600, err_calib*3600  # kg/h

    def ime(self):
        """Calculate the emission rate (kg/h) using IME method

        Return:
            wspd: Mean wind speed (m/s)
            wdir: Mean wind direction (deg)
            wspd_all: List of available wind speed (m/s)
            wdir_all: List of available wind direction (deg)
            wind_source_all: List of wind source (str)
            L_eff: Effctive length (m)
            U_eff: Effective wind speed (m/s)
            Q: Emission rate (kg/h)
            Q_err: STD of Q  (kg/h)
            err_random: random error (kg/h)
            err_wind: wind error (kg/h)
            err_calib: calibration error (kg/h)
        """
        # read file and pick valid data
        file_original = self.plume_nc_filename.replace('L3', 'L2').replace(f'_{self.plume_name}.nc', '.nc')
        ds_original = xr.open_dataset(file_original)
        ds = self.ds

        # area of pixel in m2
        self.area = self.pixel_res*self.pixel_res

        # calculate Leff using the root method in meter
        plume_pixel_num = (~self.gas_mask.isnull()).sum()
        l_eff = np.sqrt(plume_pixel_num * self.area).item()

        # calculate IME (kg)
        LOG.info('Calculating IME')
        self.sp = ds['sp'].mean().item()  # use the mean surface pressure (Pa)

        IME = self._ime_sum(self.gas_mask)

        # get wind info
        LOG.info('Calculating wind info')
        u10 = ds['u10'].sel(source=self.wind_source).item()
        v10 = ds['v10'].sel(source=self.wind_source).item()
        if self.wspd_manual is None:
            self.wspd = np.sqrt(u10**2 + v10**2)
        else:
            # overwrite the windspeed
            self.wspd = self.wspd_manual
        wdir = (270-np.rad2deg(np.arctan2(v10, u10))) % 360

        # check all wind products
        wind_source_all = list(ds['source'].to_numpy())
        wspd_all = np.sqrt(ds['u10']**2+ds['v10']**2)
        wdir_all = (270-np.rad2deg(np.arctan2(ds['v10'], ds['u10']))) % 360
        wspd_all = list(wspd_all.to_numpy())
        wdir_all = list(wdir_all.to_numpy())

        # effective wind speed
        u_eff = self.alpha['alpha1'] * np.log(self.wspd) + self.alpha['alpha2'] + self.alpha['alpha3'] * self.wspd

        # calculate the emission rate (kg/s)
        Q = (u_eff / l_eff * IME)

        # ---- uncertainty ----
        # 1. random
        LOG.info('Calculating random error')
        if self.land_only:
            # get lon and lat
            lon = ds_original['longitude']
            lat = ds_original['latitude']
            segmentation = Land_mask(lon.data, lat.data, source=self.land_mask_source)
            ds_original[self.gas] = ds_original[self.gas].where(segmentation)
            ds[self.gas] = ds[self.gas].where(segmentation)

        IME_std = self._calc_random_err(ds_original[self.gas], ds[self.gas])
        err_random = u_eff / l_eff * IME_std

        # 2. wind error
        LOG.info('Calculating wind error')
        err_wind = self._calc_wind_error(IME, l_eff)

        # 3. calibration error
        LOG.info('Calculating calibration error')
        err_calib = self._calc_calibration_error(IME, u_eff, l_eff)

        # sum error
        Q_err = np.sqrt(err_random**2 + err_wind**2 + err_calib**2)

        ds.close()
        ds_original.close()
        del ds, ds_original
        gc.collect()

        return self.wspd, wdir, wspd_all, wdir_all, wind_source_all, l_eff, u_eff, IME, Q*3600, Q_err*3600, \
            err_random*3600, err_wind*3600, err_calib*3600  # kg/h

    def ime_fetch(self):
        """Calculate the emission rate (kg/h) using IME-fetch method

        Return:
            Q: Emission rate (kg/h)
            Q_err: STD of Q  (kg/h)
            err_ime: ime/r error (kg/h)
            err_wind: wind error (kg/h)
        """
        # create mask centered on source point
        LOG.info('Calculating the index of source loc')
        y_target, x_target = self._get_index_nearest(
            self.gas_mask['longitude'], self.gas_mask['latitude'], self.longitude_source, self.latitude_source)

        mask = np.zeros(self.gas_mask.shape)
        mask[y_target, x_target] = 1

        # calculate plume height, width, and diagonal
        h = mask.shape[0]
        w = mask.shape[1]
        # r_max = np.sqrt(h**2+w**2)
        r_max = 1e3  # limit to 1 km

        # calculate IME by increasing mask radius
        LOG.info('Calculating IME at different radii')
        ime = []
        for r in np.arange(r_max):
            r += 1
            LOG.debug(f'IME {r} loop')
            mask = self._create_circular_mask(h, w,
                                              center=(x_target, y_target),
                                              radius=r)

            # Calculate IME (kg) inside the radius mask
            gas_mask = self.gas_mask.where(mask)
            IME = self._ime_sum(gas_mask)
            ime.append(IME)

            # no new plume pixels anymore
            if mask.all():
                LOG.info(f'Masking iteration stops at r = {r}')
                break

        # calculate emission rate
        L = (np.arange(len(ime))+1) * self.pixel_res
        ime_l_mean = np.mean(ime/L)
        ime_l_std = np.std(ime/L)
        Q = (ime_l_mean * self.wspd).item()

        # ---- uncertainty ----
        # 1. ime
        LOG.info('Calculating IME error')
        err_ime = Q * ime_l_std / ime_l_mean

        # 2. wind error
        LOG.info('Calculating wind error')
        err_wind = self._calc_wind_error_fetch(ime_l_mean)

        # sum error
        Q_err = np.sqrt(err_ime**2 + err_wind**2)

        return Q*3600, Q_err*3600, err_ime*3600, err_wind*3600  # kg/h
