#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright (c) 2023 HyperGas developers
#
# This file is part of hypergas.
#
# hypergas is a library to retrieve trace gases from hyperspectral satellite data
"""IME/CSF method of calculating gas emission rates"""

import gc
import logging

import numpy as np
import pyresample
import xarray as xr
from pyresample.geometry import SwathDefinition

from hypergas.landmask import Land_mask

# set the logger level
logging.basicConfig(level=logging.INFO,
                    format='%(asctime)s - %(name)s - %(levelname)s: %(message)s',
                    datefmt='%Y/%m/%d %H:%M:%S')
LOG = logging.getLogger(__name__)


# constants
mass = {'ch4': 16.04e-3, 'co2': 44.01e-3, 'co': 28.01e-3}  # molar mass [kg/mol]
mass_dry_air = 28.964e-3  # molas mass dry air [kg/mol]
grav = 9.8  # gravity (m s-2)
molar_volume = 22.4  # L/mol at STP


'''
instrument data
    pixel_res: meters
    alpha: IME alphas
'''
emit_info = {
    'platform': 'EMIT', 'instrument': 'emi', 'provider': 'NASA-JPL', 'pixel_res': 60,
    'alpha_area': {'alpha1': 0., 'alpha2': 0.67, 'alpha3': 0.45},
    'alpha_point': {'alpha1': 0., 'alpha2': 0.28, 'alpha3': 0.49},
}

enmap_info = {
    'platform': 'EnMAP', 'instrument': 'hsi', 'provider': 'DLR', 'pixel_res': 30,
    'alpha_area': {'alpha1': 0., 'alpha2': 0.69, 'alpha3': 0.37},
    'alpha_point': {'alpha1': 0., 'alpha2': 0.43, 'alpha3': 0.38},
}
prisma_info = {
    'platform': 'PRISMA', 'instrument': 'hsi', 'provider': 'ASI', 'pixel_res': 30,
    'alpha_area': {'alpha1': 0., 'alpha2': 0.70, 'alpha3': 0.37},
    'alpha_point': {'alpha1': 0., 'alpha2': 0.42, 'alpha3': 0.39},
}
sensor_info = {'EMIT': emit_info, 'EnMAP': enmap_info, 'PRISMA': prisma_info}


class IME_CSF():
    def __init__(self, sensor,
                 longitude_source, latitude_source,
                 plume_nc_filename, plume_name, ipcc_sector,
                 gas='ch4', wind_source='ERA5', wspd_manual=None,
                 land_only=True, land_mask_source='OSM'):
        """Initialize IME_CSF.

        Args:
            sensor (str):
                satellite sensor name
            longitude_source (float):
                longitude of plume source
            latitude_source (float):
                latitude of plume source
            plume_nc_filename (str):
                plume NetCDF file generated by `emiss.export_plume_nc`
            plume_name (str):
                the plume name (e.g. 'plume0')
            ipcc_sector (str):
                the sector name
                    'Electricity Generation (1A1)', 'Coal Mining (1B1a)',
                    'Oil & Gas (1B2)', 'Livestock (4B)', 'Solid Waste (6A)', 'Other'
            gas (str):
                the trace gas name
            wind_source (str):
                wind source name
            wspd_manual (float):
                Default: None (using the wspd from wind_source data)
            land_only (boolean):
                whether only considering land pixels
            land_mask_source:
                data source for creating land mask
        """
        self.gas = gas
        self.longitude_source = longitude_source
        self.latitude_source = latitude_source
        self.plume_nc_filename = plume_nc_filename
        self.plume_name = plume_name
        self.wind_source = wind_source
        self.wspd_manual = wspd_manual
        self.land_only = land_only
        self.land_mask_source = land_mask_source

        self.info = sensor_info[sensor]
        self.pixel_res = self.info['pixel_res']

        if ipcc_sector == 'Solid Waste (6A)':
            self.alpha = self.info['alpha_area']
            self.alpha_replace = self.info['alpha_point']
        else:
            self.alpha = self.info['alpha_point']
            self.alpha_replace = self.info['alpha_area']

    def calc_emiss(self):
        """Calculate emission rate (kg/h)"""
        wind_speed, wdir, wind_speed_all, wdir_all, wind_source_all, l_eff, u_eff, IME, Q, Q_err, \
            err_random, err_wind, err_calib = self.ime()
        Q_fetch, Q_fetch_err, err_ime_fetch, err_wind_fetch = self.ime_fetch()

        return wind_speed, wdir, wind_speed_all, wdir_all, wind_source_all, l_eff, u_eff, IME, Q, Q_err, \
            err_random, err_wind, err_calib, Q_fetch, Q_fetch_err, err_ime_fetch, err_wind_fetch

    def _create_circular_mask(self, h, w, center=None, radius=None):
        """Create circle mask by radius and center"""
        if center is None:
            # use the middle of the image
            center = (int(w/2), int(h/2))
        if radius is None:
            # use the smallest distance between the center and image walls
            radius = min(center[0], center[1], w-center[0], h-center[1])

        Y, X = np.ogrid[:h, :w]
        dist_from_center = np.sqrt((X - center[0])**2 + (Y-center[1])**2)

        mask = dist_from_center <= radius

        return mask

    def _ime_radius(self, da_gas, mask):
        """Calculate IME (kg) inside the radius mask"""
        gas_mask = da_gas.where(mask)
        unit = gas_mask.attrs['units']

        if unit == 'ppb':
            delta_omega = gas_mask * 1.0e-9 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif unit == 'ppm':
            delta_omega = gas_mask * 1.0e-6 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif unit == 'ppm m':
            delta_omega = gas_mask * (1/1e6) * (1000) * (1/molar_volume) * mass[self.gas]
        else:
            raise ValueError(f"Unit '{unit}' is not supported yet. Please add it here.")

        IME = np.nansum(delta_omega * self.area)

        return IME

    def _get_index_nearest(self, lons, lats, lon_target, lat_target):
        # define the areas for data and source point
        area_source = SwathDefinition(lons=lons, lats=lats)
        area_target = SwathDefinition(lons=np.array([lon_target]), lats=np.array([lat_target]))

        # Determine nearest (w.r.t. great circle distance) neighbour in the grid.
        _, _, index_array, distance_array = pyresample.kd_tree.get_neighbour_info(
            source_geo_def=area_source, target_geo_def=area_target, radius_of_influence=50,
            neighbours=1)

        # get_neighbour_info() returns indices in the flattened lat/lon grid. Compute the 2D grid indices:
        y_target, x_target = np.unravel_index(index_array, area_source.shape)

        return y_target, x_target

    def _calc_wind_error(self, IME, l_eff):
        """Calculate wind error with random distribution"""
        # Generate U10 distribution
        #   uncertainty = 50%, if wspd <= 3 m/s
        #   uncertainty = 1.5 m/s, if wspd > 3 m/s
        if self.wspd <= 3:
            sigma = self.wspd * 0.5
        else:
            sigma = 1.5

        wspd_distribution = np.random.normal(self.wspd, sigma, size=1000)

        # Calculate Ueff distribution
        u_eff_distribution = self.alpha['alpha1'] * np.log(wspd_distribution) + \
            self.alpha['alpha2'] + self.alpha['alpha3'] * wspd_distribution

        # Calculate Q distribution
        Q_distribution = u_eff_distribution * IME / l_eff

        # Calculate standard deviation of Q distribution
        wind_error = np.nanstd(Q_distribution)

        return wind_error

    def _calc_wind_error_fetch(self, ime_l_mean):
        """Calculate wind error with random distribution for IME-fetch"""
        if self.wspd <= 3:
            sigma = self.wspd * 0.5
        else:
            sigma = 1.5

        wspd_distribution = np.random.normal(self.wspd, sigma, size=1000)

        # Calculate Q distribution
        Q_distribution = ime_l_mean * wspd_distribution

        # Calculate standard deviation of Q distribution
        wind_error = np.std(Q_distribution)

        return wind_error

    def _calc_random_err(self, da_gas, gas_mask):
        """Calculate random error by moving plume around the whole scene"""
        # crop gas field to valid region
        gas_mask_crop = gas_mask.where(~gas_mask.isnull()).dropna(dim='y', how='all').dropna(dim='x', how='all')

        # get the shape of input data and mask
        bkgd_rows, bkgd_cols = gas_mask.shape
        mask_rows, mask_cols = gas_mask_crop.shape

        # Insert plume mask data at a random position
        IME_noplume = []

        while len(IME_noplume) <= 500:
            # Generate random row and column index to place b inside a
            row_idx = np.random.randint(0, bkgd_rows - mask_rows)
            col_idx = np.random.randint(0, bkgd_cols - mask_cols)

            if not np.any(da_gas[row_idx:row_idx+mask_rows, col_idx:col_idx+mask_cols].isnull()):
                gas_bkgd_mask = xr.zeros_like(da_gas)
                gas_bkgd_mask[row_idx:row_idx+mask_rows, col_idx:col_idx+mask_cols] = gas_mask_crop.values
                gas_bkgd_mask = gas_bkgd_mask.fillna(0)
                unit = da_gas.attrs['units']
                if unit == 'ppb':
                    IME_noplume.append(da_gas.where(gas_bkgd_mask, drop=True).sum().values *
                                       1.0e-9 * (mass[self.gas] / mass_dry_air) * self.sp / grav * self.area)
                elif unit == 'ppm':
                    IME_noplume.append(da_gas.where(gas_bkgd_mask, drop=True).sum().values *
                                       1.0e-6 * (mass[self.gas] / mass_dry_air) * self.sp / grav * self.area)
                elif unit == 'ppm m':
                    IME_noplume.append(da_gas.where(gas_bkgd_mask, drop=True).sum().values *
                                       (1/1e6) * (1000) * (1/molar_volume) * mass[self.gas] * self.area)
                else:
                    raise ValueError(f"Unit '{unit}' is not supported yet. Please add it here.")

        std_value = np.array(IME_noplume).std()
        del IME_noplume
        gc.collect()

        return std_value

    def _calc_calibration_error(self, IME, u_eff, l_eff):
        """Calculate wind calibration error by replacing alphas"""
        # Calculate Ueff
        u_eff_replace = self.alpha_replace['alpha1'] * \
            np.log(self.wspd) + self.alpha_replace['alpha2'] + self.alpha_replace['alpha3'] * self.wspd

        # Calculate uncertainty
        error = abs(u_eff_replace - u_eff) * IME / l_eff

        return error

    def ime(self):
        """Calculate the emission rate (kg/h) using IME method

        Return:
            wspd: Mean wind speed (m/s)
            wdir: Mean wind direction (deg)
            wspd_all: List of available wind speed (m/s)
            wdir_all: List of available wind direction (deg)
            wind_source_all: List of wind source (str)
            L_eff: Effctive length (m)
            U_eff: Effective wind speed (m/s)
            Q: Emission rate (kg/h)
            Q_err: STD of Q  (kg/h)
            err_random: random error (kg/h)
            err_wind: wind error (kg/h)
            err_calib: calibration error (kg/h)
        """
        # read file and pick valid data
        file_original = self.plume_nc_filename.replace('L3', 'L2').replace(f'_{self.plume_name}.nc', '.nc')
        ds_original = xr.open_dataset(file_original)
        ds = xr.open_dataset(self.plume_nc_filename)

        # get the masked plume data
        gas_mask = ds.dropna(dim='y', how='all').dropna(dim='x', how='all')[self.gas]

        # area of pixel in m2
        self.area = self.pixel_res*self.pixel_res

        # calculate Leff using the root method in meter
        plume_pixel_num = (~gas_mask.isnull()).sum()
        l_eff = np.sqrt(plume_pixel_num * self.area).item()

        # calculate IME (kg)
        LOG.info('Calculating IME')
        self.sp = ds['sp'].mean().item()  # use the mean surface pressure (Pa)
        unit = gas_mask.attrs['units']

        if unit == 'ppb':
            delta_omega = gas_mask * 1.0e-9 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif unit == 'ppm':
            delta_omega = gas_mask * 1.0e-6 * (mass[self.gas] / mass_dry_air) * self.sp / grav
        elif unit == 'ppm m':
            delta_omega = gas_mask * (1/1e6) * (1000) * (1/molar_volume) * mass[self.gas]
        else:
            raise ValueError(f"Unit '{unit}' is not supported yet. Please add it here.")

        IME = np.nansum(delta_omega * self.area)

        # get wind info
        LOG.info('Calculating wind info')
        u10 = ds['u10'].sel(source=self.wind_source).item()
        v10 = ds['v10'].sel(source=self.wind_source).item()
        if self.wspd_manual is None:
            self.wspd = np.sqrt(u10**2 + v10**2)
        else:
            # overwrite the windspeed
            self.wspd = self.wspd_manual
        wdir = (270-np.rad2deg(np.arctan2(v10, u10))) % 360

        # check all wind products
        wind_source_all = list(ds['source'].to_numpy())
        wspd_all = np.sqrt(ds['u10']**2+ds['v10']**2)
        wdir_all = (270-np.rad2deg(np.arctan2(ds['v10'], ds['u10']))) % 360
        wspd_all = list(wspd_all.to_numpy())
        wdir_all = list(wdir_all.to_numpy())

        # effective wind speed
        u_eff = self.alpha['alpha1'] * np.log(self.wspd) + self.alpha['alpha2'] + self.alpha['alpha3'] * self.wspd

        # calculate the emission rate (kg/s)
        Q = (u_eff / l_eff * IME)

        # ---- uncertainty ----
        # 1. random
        LOG.info('Calculating random error')
        if self.land_only:
            # get lon and lat
            lon = ds_original['longitude']
            lat = ds_original['latitude']
            segmentation = Land_mask(lon.data, lat.data, source=self.land_mask_source)
            ds_original[self.gas] = ds_original[self.gas].where(segmentation)
            ds[self.gas] = ds[self.gas].where(segmentation)

        IME_std = self._calc_random_err(ds_original[self.gas], ds[self.gas])
        err_random = u_eff / l_eff * IME_std

        # 2. wind error
        LOG.info('Calculating wind error')
        err_wind = self._calc_wind_error(IME, l_eff)

        # 3. calibration error
        LOG.info('Calculating calibration error')
        err_calib = self._calc_calibration_error(IME, u_eff, l_eff)

        # sum error
        Q_err = np.sqrt(err_random**2 + err_wind**2 + err_calib**2)

        ds.close()
        ds_original.close()

        return self.wspd, wdir, wspd_all, wdir_all, wind_source_all, l_eff, u_eff, IME, Q*3600, Q_err*3600, \
            err_random*3600, err_wind*3600, err_calib*3600  # kg/h

    def ime_fetch(self):
        """Calculate the emission rate (kg/h) using IME-fetch method

        Return:
            Q: Emission rate (kg/h)
            Q_err: STD of Q  (kg/h)
            err_ime: ime/r error (kg/h)
            err_wind: wind error (kg/h)
        """
        # read file and pick valid data
        LOG.info('Reading data')
        ds = xr.open_dataset(self.plume_nc_filename)

        # get the masked plume data
        gas_mask = ds.dropna(dim='y', how='all').dropna(dim='x', how='all')[self.gas]

        # create mask centered on source point
        LOG.info('Calculating the index of source loc')
        y_target, x_target = self._get_index_nearest(
            gas_mask['longitude'], gas_mask['latitude'], self.longitude_source, self.latitude_source)

        mask = np.zeros(gas_mask.shape)
        mask[y_target, x_target] = 1

        # calculate plume height, width, and diagonal
        h = mask.shape[0]
        w = mask.shape[1]
        # r_max = np.sqrt(h**2+w**2)
        r_max = 1e3  # limit to 1 km

        # calculate IME by increasing mask radius
        LOG.info('Calculating IME at different radii')
        ime = []
        for r in np.arange(r_max):
            r += 1
            LOG.debug(f'IME {r} loop')
            mask = self._create_circular_mask(h, w,
                                              center=(x_target, y_target),
                                              radius=r)

            IME = self._ime_radius(gas_mask, mask)
            ime.append(IME)

            # no new plume pixels anymore
            if mask.all():
                LOG.info(f'Masking iteration stops at r = {r}')
                break

        # calculate emission rate
        L = (np.arange(len(ime))+1) * self.pixel_res
        ime_l_mean = np.mean(ime/L)
        ime_l_std = np.std(ime/L)
        Q = (ime_l_mean * self.wspd).item()

        # ---- uncertainty ----
        # 1. ime
        LOG.info('Calculating IME error')
        err_ime = Q * ime_l_std / ime_l_mean

        # 2. wind error
        LOG.info('Calculating wind error')
        err_wind = self._calc_wind_error_fetch(ime_l_mean)

        # sum error
        Q_err = np.sqrt(err_ime**2 + err_wind**2)

        ds.close()

        return Q*3600, Q_err*3600, err_ime*3600, err_wind*3600  # kg/h
